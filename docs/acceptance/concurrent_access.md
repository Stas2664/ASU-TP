# Алгоритм единовременного доступа к объектам БД

Конфиденциально. Публикация без разрешения Заказчика запрещена (п.5.4 ТЗ).

## 1. Цель
Обеспечить редактирование объекта (параметра, экрана, алгоритма и т.д.) строго одним пользователем одновременно.

## 2. Механика (advisory locks PostgreSQL)

Функции:
- `core.acquire_object_lock(object_type, object_id, user_id, timeout_seconds)` — попытка захвата замка. Возвращает boolean.
- `core.release_object_lock(object_type, object_id, user_id)` — освобождение замка. Возвращает boolean.

Ключ блокировки: `hashtext(object_type || '::' || object_id)`.
Все события пишутся в `security.audit_log` (успех/ошибка, время, пользователь).

## 3. Флоу использования в приложении
1) Перед открытием формы редактирования:
   - вызвать `acquire_object_lock(...)` с таймаутом 30–60 сек.
   - если FALSE — показать пользователю, кто держит блокировку (см. audit_log) и предложить открыть в режиме просмотра.
2) На сохранение/закрытие формы:
   - выполнить `release_object_lock(...)`.
3) На аварийный выход (сбой клиента):
   - по таймауту замок освобождается оператором (интерфейс администратора) либо при завершении сессии.

## 4. Точки интеграции
- UI редакторов (параметры, экраны, алгоритмы)
- API слоев для валидации перед записью

## 5. Примеры SQL
```sql
-- Захват
SELECT core.acquire_object_lock('parameter', :id, :user_id, 30);
-- Освобождение
SELECT core.release_object_lock('parameter', :id, :user_id);
```

## 6. Ограничения и замечания
- Замки advisory — процессные, рассчитываются по ключу; использовать аккуратно в кластере.
- Рекомендуется принудительное снятие администратором при зависших сессиях.
